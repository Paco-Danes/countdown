<script>
  const $ = sel => document.querySelector(sel);

  const dEl = $("#d"), hEl = $("#h"), mEl = $("#m"), sEl = $("#s");
  const input = $("#until");
  const saveBtn = $("#save");
  const shareBtn = $("#share");
  const statusEl = $("#status");
  const tzEl = $("#tz");
  const boy = $("#boy"), girl = $("#girl"), hearts = $("#hearts");
  const bar = $("#bar");
  const scene = document.querySelector(".scene");

  const LS_TARGET = "countdown:targetISO";
  const LS_STARTED = "countdown:startedISO";

  // 1) ALWAYS clean our localStorage on page load
  (function cleanStorageOnLoad() {
    try {
      localStorage.removeItem(LS_TARGET);
      localStorage.removeItem(LS_STARTED);
    } catch {}
  })();

  tzEl.textContent = `Your timezone: ${Intl.DateTimeFormat().resolvedOptions().timeZone}`;

  function pad(n) { return String(n).padStart(2, "0"); }
  function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

  // format Date -> yyyy-MM-ddTHH:mm for input[type=datetime-local]
  function toLocalInputValue(dt) {
      const z = new Date(dt.getTime() - dt.getTimezoneOffset() * 60000);
      return z.toISOString().slice(0, 16);
  }

  function parseQueryTarget() {
      const p = new URLSearchParams(location.search);
      const u = p.get("until");
      if (!u) return null;
      const dt = new Date(u);
      return isNaN(dt.getTime()) ? null : dt;
  }

  // 2) Use URL ?until=... if present, otherwise the fixed default
  function readInitialTarget() {
      return parseQueryTarget()
          || new Date("2025-10-24T20:25:00");
  }

  function setTarget(dt, setStarted = true) {
      if (!(dt instanceof Date) || isNaN(dt)) return;
      localStorage.setItem(LS_TARGET, dt.toISOString());
      if (setStarted) {
          const now = new Date();
          localStorage.setItem(LS_STARTED, now.toISOString());
      }
      // reflect in URL (shareable)
      const url = new URL(location.href);
      url.searchParams.set("until", dt.toISOString());
      history.replaceState(null, "", url);
      input.value = toLocalInputValue(dt);
      feedback("Saved ✓");
  }

  function getStarted() {
      const s = localStorage.getItem(LS_STARTED);
      return s ? new Date(s) : null;
  }

  function feedback(msg) {
      statusEl.textContent = msg;
      clearTimeout(feedback._t);
      feedback._t = setTimeout(() => statusEl.textContent = "", 2000);
  }

  // Compute stick travel distance in px so they meet at center
  let travels = { boy: 0, girl: 0 };
  function computeTravels() {
      const rect = scene.getBoundingClientRect();
      const center = rect.width / 2;
      const bw = boy.offsetWidth, gw = girl.offsetWidth;
      travels.boy = center - bw / 2 - 10;     // small overlap margin
      travels.girl = center - gw / 2 - 10;
  }
  window.addEventListener("resize", computeTravels);

  function tick() {
      // Always read from localStorage (which was seeded from URL/default at init)
      const targetStr = localStorage.getItem(LS_TARGET);
      const target = targetStr ? new Date(targetStr) : new Date();
      const started = getStarted() || new Date();

      const now = new Date();
      const totalMs = Math.max(0, target - now);
      const d = Math.floor(totalMs / (24 * 60 * 60 * 1000));
      const h = Math.floor((totalMs % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000));
      const m = Math.floor((totalMs % (60 * 60 * 1000)) / (60 * 1000));
      const s = Math.floor((totalMs % (60 * 1000)) / 1000);

      dEl.textContent = d;
      hEl.textContent = pad(h);
      mEl.textContent = pad(m);
      sEl.textContent = pad(s);

      // Progress for bar + figures:
      const denom = Math.max(1, target - started); // avoid /0
      const progress = clamp(1 - ((target - now) / denom), 0, 1);
      document.documentElement.style.setProperty("--progress", progress.toFixed(6));
      bar.style.width = `calc(${(progress * 100).toFixed(4)}%)`;

      // Move stick figures
      boy.style.transform = `translateX(${(progress * travels.boy).toFixed(2)}px)`;
      girl.style.transform = `translateX(${(-progress * travels.girl).toFixed(2)}px)`;

      // Hearts on finish
      if (totalMs <= 0) {
          hearts.classList.add("show");
      } else {
          hearts.classList.remove("show");
      }

      requestAnimationFrame(tick);
  }

  // ===== Init =====
  const initTarget = readInitialTarget();

  // Seed both UI and storage from chosen target (URL wins, else default)
  input.value = toLocalInputValue(initTarget);
  setTarget(initTarget, true); // writes LS_TARGET/LS_STARTED and updates URL & input

  computeTravels();
  requestAnimationFrame(tick);

  // Events
  saveBtn.addEventListener("click", () => {
      const v = input.value;
      if (!v) { feedback("Pick a date/time"); return; }
      const local = new Date(v);
      if (isNaN(local.getTime())) { feedback("Invalid date"); return; }
      setTarget(local, true);
  });

  shareBtn.addEventListener("click", async () => {
      try {
          await navigator.clipboard.writeText(location.href);
          feedback("Link copied ✨");
      } catch {
          feedback("Copy failed — you can copy the URL bar");
      }
  });
</script>
